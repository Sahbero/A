<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>HALKA — Güncel</title>
<style>
  :root{
    --bg:#0e0f14;
    --ink:#e6e6e6;
    --ink-dim:#b8b8c2;
    --acc1:#7AE582;
    --acc2:#5AA9E6;
    --acc3:#FFD166;
    --acc4:#EF476F;
    --shadow: rgba(0,0,0,0.5);
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #c{display:block;width:100vw;height:100vh;touch-action:none;background:#111}

  .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .panel{pointer-events:auto;background:rgba(20,22,30,0.88);backdrop-filter:blur(4px);border-radius:12px;padding:18px;max-width:720px;box-shadow:0 10px 30px var(--shadow);}
  h1{margin:0 0 8px;font-size:22px}
  p{margin:6px 0 10px;color:var(--ink-dim)}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .btn{appearance:none;border:0;border-radius:10px;padding:10px 14px;font-weight:600;cursor:pointer;background:#222;color:var(--ink);box-shadow:0 6px 16px var(--shadow)}
  .k{display:inline-block;padding:2px 8px;border-radius:6px;background:#202432;color:var(--ink);font-weight:600}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  @media(max-width:640px){.grid{grid-template-columns:1fr}}

  #mob{position:fixed;left:10px;right:110px;bottom:10px;display:flex;gap:10px;pointer-events:none}
  .mbtn{pointer-events:auto;min-width:100px;padding:10px;border-radius:10px;background:#1e2330;color:var(--ink)}

  /* Dairesel bariyer butonu (küçük) */
  #barUI{position:fixed;right:12px;bottom:12px;width:59px;height:59px;pointer-events:none;z-index:40}
  #barBtn{
    position:absolute;inset:0;border:0;border-radius:50%;background:#1c2130;color:var(--ink);font-weight:700;font-size:12px;
    box-shadow:0 8px 20px var(--shadow), inset 0 0 0 1px rgba(255,255,255,0.04);cursor:pointer;pointer-events:auto;
  }
  #barRing{position:absolute;inset:-4px;width:calc(100% + 8px);height:calc(100% + 8px);pointer-events:none}
</style>
</head>
<body>
<canvas id="c"></canvas>

<!-- Menü -->
<div class="overlay" id="menu">
  <div class="panel">
    <h1>HALKA</h1>
    <p>Merkeze yakın kal. Düşmanları yok et. <strong>Her 10 öldürmede koruyucu bariyer 'hazır' olur</strong> — hazır olunca butona basarak 5 sn aktif edebilirsiniz. Yer-bariyeri (E) ve diğer mekanikler korunmuştur.</p>
    <div class="grid">
      <div>
        <strong>Kontroller (PC)</strong>
        <p><span class="k">WASD</span> hareket • Fare: nişan • <span class="k">Sol Tık</span> ateş<br>
           <span class="k">Shift</span> dash • <span class="k">E</span> yer bariyeri • <span class="k">R</span> yön • <span class="k">Esc</span> duraklat</p>
      </div>
      <div>
        <strong>Mobil</strong>
        <p>Sol alan: hareket • Sağ alan: nişan/ateş • Sağ alttaki dairesel buton: koruyucu bariyeri aktive et (hazırsa).</p>
      </div>
    </div>
    <div style="margin-top:10px"><strong>En İyi Skor: </strong><span id="best">0</span></div>
    <div class="row" style="margin-top:10px">
      <button class="btn" id="start">BAŞLA</button>
      <button class="btn" id="how">NASIL OYNANIR</button>
    </div>
    <div id="howbox" style="display:none;margin-top:10px"><p style="color:var(--ink-dim)">Yer-bariyeri (E) korunmuştur. Koruyucu bariyer yalnızca <strong>hazır</strong>ken butona tıklanarak aktive edilir ve 5 saniye sürer; bu süre içinde çembere giren düşmanlar anında ölür. Skor her öldürmede +10 puandır.</p></div>
  </div>
</div>

<div id="mob" aria-hidden="true"><button class="mbtn" id="mbPause">Duraklat (Esc)</button></div>

<!-- Dairesel bariyer butonu -->
<div id="barUI" aria-hidden="false">
  <button id="barBtn" title="Koruyucu Bariyer (hazırsa)">B</button>
  <canvas id="barRing"></canvas>
</div>

<script>
(() => {
  'use strict';

  /* ---------- yardımcılar ---------- */
  const rand = (a = 1, b = 0) => Math.random() * (b - a) + a;
  const clamp = (v, a, b) => v < a ? a : (v > b ? b : v);
  const lerp = (a, b, t) => a + (b - a) * t;
  const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
  const now = () => performance.now();

  /* ---------- canvas / dpr ---------- */
  const dpr = Math.max(1, Math.min(2, devicePixelRatio || 1));
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  function resize() {
    canvas.width = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
  }
  addEventListener('resize', resize, { passive: true });
  resize();

  /* ---------- audio (light) ---------- */
  const AC = window.AudioContext || window.webkitAudioContext;
  const audio = new AC();
  let muted = false;
  function beep({ freq = 440, time = 0.06, type = 'sine', vol = 0.05 } = {}) {
    if (muted) return;
    const t0 = audio.currentTime;
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol; g.gain.setValueAtTime(vol, t0);
    g.gain.exponentialRampToValueAtTime(0.0001, t0 + time);
    o.connect(g).connect(audio.destination); o.start(t0); o.stop(t0 + time);
  }
  const sShoot = () => beep({ freq: 720, time: .05, type: 'square', vol: 0.06 });
  const sHit = () => beep({ freq: 160, time: .08, type: 'sawtooth', vol: 0.06 });
  const sKill = () => beep({ freq: 320, time: .09, type: 'triangle', vol: 0.07 });
  const sHurt = () => beep({ freq: 110, time: .12, type: 'sawtooth', vol: 0.08 });
  const sDash = () => beep({ freq: 900, time: .05, type: 'square', vol: 0.06 });
  const sBarrier = () => beep({ freq: 460, time: .12, type: 'triangle', vol: 0.07 });

  /* ---------- durum & UI ---------- */
  const State = { MENU: 0, PLAY: 1, PAUSE: 2, DEAD: 3 };
  let state = State.MENU;
  const menuEl = document.getElementById('menu');
  const startBtn = document.getElementById('start');
  const howBtn = document.getElementById('how');
  const howBox = document.getElementById('howbox');
  const bestEl = document.getElementById('best');
  const mbPauseBtn = document.getElementById('mbPause');

  const barBtn = document.getElementById('barBtn');
  const ring = document.getElementById('barRing');
  const rctx = ring.getContext('2d');

  function sizeRing() {
    const px = 59; // buton kutusu boyutu (küçültülmüş)
    ring.width = Math.floor((px + 8) * dpr);
    ring.height = Math.floor((px + 8) * dpr);
    ring.style.width = (px + 8) + 'px';
    ring.style.height = (px + 8) + 'px';
  }
  sizeRing(); addEventListener('resize', sizeRing, { passive: true });

  const LS_KEY = 'HALKA_BEST';
  let bestScore = +(localStorage.getItem(LS_KEY) || 0);
  bestEl.textContent = bestScore.toLocaleString('tr-TR');

  const world = { w: () => canvas.width, h: () => canvas.height, cx: () => canvas.width / 2, cy: () => canvas.height / 2 };

  /* ---------- oyuncu & parametreler ---------- */
  const player = {
    x: world.cx(), y: world.cy(), vx: 0, vy: 0, r: 14 * dpr,
    hp: 100, hpMax: 100,
    fireCD: 0, fireRate: .12,
    dashCD: 0, dashCDMax: 1.2, dashPow: 7 * dpr,
    score: 0, mult: 1, multTimer: 0
  };

  const params = {
    safeRadius: Math.min(world.w(), world.h()) * 0.42,
    safeShrinkPerSec: 8 * dpr,
    outDPS: 14,
    enemySpawn: 0, enemySpawnRate: 0.9,
    enemySpeedBase: 0.18 * dpr,
    enemyHpBase: 16,
    enemyRamp: 0
  };

  /* ---------- koruyucu bariyer (yeni davranış) ---------- */
  let killsSinceLastActivation = 0;
  let barrierAutoReady = false;      // hazır olduğunda true (10 kill sonrası)
  let barrierAutoActive = false;     // aktif olduğunda true
  const barrierAutoDuration = 5.0;   // 5 saniye
  let barrierAutoTimer = 0;
  const barrierRadius = 58 * dpr;

  /* ---------- yer-bariyeri (orijinal mekanik korunur) ---------- */
  let barrierRot = 0; const barriers = []; let barrierIdSeq = 1;
  const barrierHPDrain = 2;
  const barrierCD = { cd: 0, cdMax: 5.0 };
  function placeBarrier() {
    // artık shard yok; yalnızca CD kontrolü var
    if (barrierCD.cd > 0) return;
    sBarrier();
    const rot = barrierRot ? Math.PI / 2 : 0;
    const len = 80 * dpr, thick = 12 * dpr;
    const dx = Math.cos(rot), dy = Math.sin(rot);
    barriers.push({
      id: barrierIdSeq++,
      x: clamp(player.x + dx * 24 * dpr, 40, world.w() - 40),
      y: clamp(player.y + dy * 24 * dpr, 40, world.h() - 40),
      w: rot ? thick : len, h: rot ? len : thick,
      hp: 140, hpMax: 140, rot
    });
    barrierCD.cd = barrierCD.cdMax;
  }

  /* ---------- girdi (klavye/mouse/touch) ---------- */
  const keys = new Set();
  addEventListener('keydown', e => {
    if (e.key === ' ' || e.key === 'ArrowUp') e.preventDefault();
    keys.add((e.key || '').toLowerCase());
    if (e.key === 'Escape') {
      if (state === State.PLAY) { state = State.PAUSE; menuEl.style.display = ''; }
      else if (state === State.PAUSE) { state = State.PLAY; menuEl.style.display = 'none'; }
    }
  });
  addEventListener('keyup', e => keys.delete((e.key || '').toLowerCase()));

  let mouse = { x: player.x, y: player.y, down: false };
  canvas.addEventListener('mousemove', e => { mouse.x = e.offsetX * dpr; mouse.y = e.offsetY * dpr; });
  canvas.addEventListener('mousedown', e => { mouse.down = true; audio.resume(); if (e.button === 2) e.preventDefault(); });
  canvas.addEventListener('mouseup', () => { mouse.down = false; });
  canvas.addEventListener('contextmenu', e => e.preventDefault());

  let touchL = null, touchR = null;
  canvas.addEventListener('touchstart', e => {
    audio.resume();
    for (const t of e.changedTouches) {
      const isLeft = t.clientX < innerWidth / 2;
      const o = { id: t.identifier, sx: t.clientX, sy: t.clientY, x: t.clientX, y: t.clientY };
      if (isLeft && !touchL) touchL = o; else if (!isLeft && !touchR) touchR = o;
    }
  }, { passive: true });
  canvas.addEventListener('touchmove', e => {
    for (const t of e.changedTouches) {
      if (touchL && t.identifier === touchL.id) { touchL.x = t.clientX; touchL.y = t.clientY; }
      if (touchR && t.identifier === touchR.id) { touchR.x = t.clientX; touchR.y = t.clientY; }
    }
  }, { passive: true });
  canvas.addEventListener('touchend', e => {
    for (const t of e.changedTouches) {
      if (touchL && t.identifier === touchL.id) touchL = null;
      if (touchR && t.identifier === touchR.id) touchR = null;
    }
  }, { passive: true });

  mbPauseBtn.addEventListener('click', () => {
    if (state === State.PLAY) { state = State.PAUSE; menuEl.style.display = ''; }
    else if (state === State.PAUSE) { state = State.PLAY; menuEl.style.display = 'none'; }
  });

  /* ---------- buton: koruyucu bariyeri aktive etme (sadece hazırsa) ---------- */
  barBtn.addEventListener('click', () => {
    if (barrierAutoReady && !barrierAutoActive) {
      barrierAutoActive = true;
      barrierAutoTimer = barrierAutoDuration;
      barrierAutoReady = false;
      killsSinceLastActivation = 0;
      sBarrier();
    } else {
      // hazır değilse hafif uyarı sesi
      beep({ freq: 220, time: 0.06, vol: 0.03 });
    }
  });

  /* ---------- UI butonları ---------- */
  startBtn.onclick = () => resetGame();
  howBtn.onclick = () => { howBox.style.display = howBox.style.display ? '' : 'none'; };

  /* ---------- oyun nesneleri ---------- */
  const bullets = [], enemies = [], particles = [];

  /* ---------- spawn ---------- */
  function spawnEnemy() {
    const pad = 40 * dpr;
    const side = (Math.random() * 4) | 0;
    let x, y;
    if (side === 0) { x = rand(-pad, world.w() + pad); y = -pad; }
    else if (side === 1) { x = world.w() + pad; y = rand(-pad, world.h() + pad); }
    else if (side === 2) { x = rand(-pad, world.w() + pad); y = world.h() + pad; }
    else { x = -pad; y = rand(-pad, world.h() + pad); }
    const speed = params.enemySpeedBase + params.enemyRamp * 0.02 + rand(0.02, 0.08) * dpr;
    const hp = params.enemyHpBase + params.enemyRamp * 2 + ((Math.random() * 6) | 0);
    enemies.push({ x, y, vx: 0, vy: 0, r: 12 * dpr, speed, hp, maxhp: hp });
  }

  /* ---------- reset / start ---------- */
  function resetGame() {
    state = State.PLAY; menuEl.style.display = 'none';
    Object.assign(player, { x: world.cx(), y: world.cy(), vx: 0, vy: 0, hp: 100, score: 0, mult: 1, multTimer: 0, fireCD: 0, dashCD: 0 });
    bullets.length = enemies.length = barriers.length = particles.length = 0;
    params.safeRadius = Math.min(world.w(), world.h()) * 0.42; params.enemySpawn = 0; params.enemyRamp = 0;
    killsSinceLastActivation = 0; barrierAutoReady = false; barrierAutoActive = false; barrierAutoTimer = 0; barrierCD.cd = 0;
  }

  /* ---------- ateş ---------- */
  function shoot() {
    const ang = Math.atan2(mouse.y - player.y, mouse.x - player.x);
    const spd = 8 * dpr;
    bullets.push({ x: player.x, y: player.y, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd, r: 4 * dpr, life: 1.1 });
    sShoot();
  }

  /* ---------- zamanlama ---------- */
  let tPrev = now();

  /* ---------- update / logic ---------- */
  function step(dt) {
    if (state !== State.PLAY) return;

    // spawn & difficulty
    params.safeRadius = Math.max(50 * dpr, params.safeRadius - params.safeShrinkPerSec * dt);
    params.enemyRamp += dt;
    params.enemySpawn += dt * params.enemySpawnRate * (1 + params.enemyRamp * 0.01);
    while (params.enemySpawn > 1) { params.enemySpawn -= 1; spawnEnemy(); }

    // hareket girdisi
    let mx = 0, my = 0;
    if (keys.has('w') || keys.has('arrowup')) my -= 1;
    if (keys.has('s') || keys.has('arrowdown')) my += 1;
    if (keys.has('a') || keys.has('arrowleft')) mx -= 1;
    if (keys.has('d') || keys.has('arrowright')) mx += 1;

    if (touchL) {
      const dx = (touchL.x - touchL.sx), dy = (touchL.y - touchL.sy);
      const m = Math.hypot(dx, dy);
      if (m > 10) { mx += dx / m; my += dy / m; }
    }

    // dash
    player.dashCD = Math.max(0, player.dashCD - dt);
    if ((keys.has('shift') || keys.has('ş')) && player.dashCD <= 0) {
      const v = Math.hypot(mx, my);
      if (v > 0.1) { player.vx += (mx / v) * player.dashPow; player.vy += (my / v) * player.dashPow; player.dashCD = player.dashCDMax; sDash(); }
    }

    // ateş
    player.fireCD = Math.max(0, player.fireCD - dt);
    const firing = mouse.down || !!touchR;
    if (firing && player.fireCD <= 0) {
      if (touchR) { mouse.x = touchR.x * dpr; mouse.y = touchR.y * dpr; }
      shoot(); player.fireCD = player.fireRate;
    }

    // yer bariyeri
    if (keys.has('e')) { keys.delete('e'); placeBarrier(); }
    if (keys.has('r')) { keys.delete('r'); barrierRot = 1 - barrierRot; }

    // hareket fiziği
    const mv = Math.hypot(mx, my);
    if (mv > 0) { mx /= mv; my /= mv; }
    player.vx = lerp(player.vx, mx * 4 * dpr, 0.18);
    player.vy = lerp(player.vy, my * 4 * dpr, 0.18);
    player.x = clamp(player.x + player.vx, 10, world.w() - 10);
    player.y = clamp(player.y + player.vy, 10, world.h() - 10);

    // dış alan hasarı (oyunun mekaniklerinden biri; görsel safe ring kaldırıldı)
    if (dist(player.x, player.y, world.cx(), world.cy()) > params.safeRadius) {
      player.hp -= params.outDPS * dt;
    }

    // mermiler
    for (let i = bullets.length - 1; i >= 0; i--) {
      const b = bullets[i];
      b.x += b.vx; b.y += b.vy; b.life -= dt;
      if (b.life <= 0 || b.x < -20 || b.x > world.w() + 20 || b.y < -20 || b.y > world.h() + 20) { bullets.splice(i, 1); continue; }
      for (const bar of barriers) {
        if (b.x > bar.x - bar.w / 2 && b.x < bar.x + bar.w / 2 && b.y > bar.y - bar.h / 2 && b.y < bar.y + bar.h / 2) {
          bullets.splice(i, 1); bar.hp -= 12; break;
        }
      }
    }

    // düşmanlar
    for (let i = enemies.length - 1; i >= 0; i--) {
      const e = enemies[i];
      const ang = Math.atan2(player.y - e.y, player.x - e.x);
      e.vx = Math.cos(ang) * e.speed; e.vy = Math.sin(ang) * e.speed;
      e.x += e.vx; e.y += e.vy;

      // yer-bariyer etkileşimi
      for (const bar of barriers) {
        if (e.x > bar.x - bar.w / 2 && e.x < bar.x + bar.w / 2 && e.y > bar.y - bar.h / 2 && e.y < bar.y + bar.h / 2) {
          e.x -= e.vx * 5; e.y -= e.vy * 5; bar.hp -= 20 * dt;
        }
      }

      // koruyucu bariyer: aktifse çembere değen düşman anında ölür
      if (barrierAutoActive && dist(e.x, e.y, player.x, player.y) <= barrierRadius + e.r) {
        enemies.splice(i, 1); onEnemyKilled(e); continue;
      }

      // güvenli alan dışı düşman hasarı
      if (dist(e.x, e.y, world.cx(), world.cy()) > params.safeRadius) e.hp -= 8 * dt;

      // mermi çarpışması
      for (let j = bullets.length - 1; j >= 0; j--) {
        const b = bullets[j];
        if (dist(b.x, b.y, e.x, e.y) < e.r + b.r) {
          bullets.splice(j, 1); e.hp -= 20; sHit();
          particles.push({ x: e.x, y: e.y, life: .2, color: getCSS('--acc4') });
        }
      }

      // oyuncuya çarpma
      if (dist(e.x, e.y, player.x, player.y) < e.r + player.r) {
        player.hp -= 22 * dt; sHurt();
        player.vx -= e.vx * 0.6; player.vy -= e.vy * 0.6;
      }

      // öldü mü?
      if (e.hp <= 0) { enemies.splice(i, 1); onEnemyKilled(e); }
    }

    // yer-bariyeri dayanıklılık
    for (let i = barriers.length - 1; i >= 0; i--) {
      const b = barriers[i]; b.hp -= barrierHPDrain * dt;
      if (b.hp <= 0) barriers.splice(i, 1);
    }

    // koruyucu bariyer zamanlayıcı
    if (barrierAutoActive) {
      barrierAutoTimer -= dt;
      if (barrierAutoTimer <= 0) { barrierAutoActive = false; barrierAutoTimer = 0; }
    }

    // hazır olma mantığı (10 öldürme => hazır)
    if (!barrierAutoReady && !barrierAutoActive && killsSinceLastActivation >= 10) {
      barrierAutoReady = true;
    }

    // yer-bariyeri CD
    if (barrierCD.cd > 0) barrierCD.cd = Math.max(0, barrierCD.cd - dt);

    // çarpan süresi (görsel/diğer kullanım korunur, puan sabit +10)
    if (player.mult > 1) { player.multTimer -= dt; if (player.multTimer <= 0) player.mult = Math.max(1, Math.floor(player.mult)); }

    // oyun sonu
    if (player.hp <= 0) endGame();
  }

  /* ---------- öldürme sonrası ---------- */
  function onEnemyKilled(e) {
    sKill();
    // İstenen: her ölende tam 10 puan ekle (çarpan kullanılmaz)
    player.score += 10;
    // Ancak çarpan mantığı görsel/diğer için korunuyor (yine artıyor)
    player.mult = Math.min(8, player.mult + 0.1);
    player.multTimer = 3;

    // Particles (korundu)
    for (let k = 0; k < 6; k++) particles.push({ x: e.x + rand(-6, 6), y: e.y + rand(-6, 6), life: .4, color: getCSS('--acc4') });

    // hazır bariyer mantığı: sayacı artır
    killsSinceLastActivation++;
    // NOT: artık otomatik aktif olmuyor — yalnızca "hazır" oluyor (barBtn ile aktive edilmelidir)
  }

  /* ---------- çizim ---------- */
  function getCSS(n) { return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }

  function draw() {
    ctx.fillStyle = getCSS('--bg'); ctx.fillRect(0, 0, world.w(), world.h());

    // yer bariyerleri (hafif görünür)
    for (const b of barriers) {
      ctx.save(); ctx.translate(b.x, b.y);
      ctx.globalAlpha = 0.08; ctx.fillStyle = '#fff'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2 * dpr;
      ctx.beginPath(); ctx.rect(-b.w / 2, -b.h / 2, b.w, b.h); ctx.fill(); ctx.stroke();
      ctx.globalAlpha = 1; ctx.restore();
    }

    // mermiler
    ctx.fillStyle = getCSS('--acc2'); for (const b of bullets) { ctx.beginPath(); ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2); ctx.fill(); }

    // düşmanlar
    for (const e of enemies) {
      const hpR = clamp(e.hp / e.maxhp, 0, 1);
      ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
      ctx.fillStyle = getCSS('--acc4'); ctx.globalAlpha = 0.88; ctx.fill(); ctx.globalAlpha = 1;
      ctx.beginPath(); ctx.arc(e.x, e.y, e.r + 3 * dpr, -Math.PI / 2, -Math.PI / 2 + hpR * 2 * Math.PI);
      ctx.strokeStyle = getCSS('--acc3'); ctx.lineWidth = 2 * dpr; ctx.stroke();
    }

    // oyuncu (kontrol edilebilir beyaz top)
    ctx.save(); ctx.translate(player.x, player.y);
    ctx.fillStyle = 'rgba(0,0,0,0.28)'; ctx.beginPath(); ctx.arc(3 * dpr, 3 * dpr, player.r, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(0, 0, player.r, 0, Math.PI * 2); ctx.fillStyle = '#dfe7fd'; ctx.fill();
    ctx.restore();

    // Koruyucu bariyer görseli
    if (barrierAutoActive) {
      ctx.save();
      ctx.shadowColor = '#fff'; ctx.shadowBlur = 20 * dpr;
      ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 4 * dpr;
      ctx.beginPath(); ctx.arc(player.x, player.y, barrierRadius, 0, Math.PI * 2); ctx.stroke();
      ctx.shadowBlur = 0; ctx.restore();
    } else {
      // pasif görünüm kaldırıldı (isteğiniz üzere)
    }

    // parçacıklar
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i]; p.life -= 1 / 60;
      ctx.globalAlpha = Math.max(0, p.life * 2); ctx.fillStyle = p.color; ctx.fillRect(p.x - 2 * dpr, p.y - 2 * dpr, 4 * dpr, 4 * dpr);
      if (p.life <= 0) particles.splice(i, 1);
      ctx.globalAlpha = 1;
    }

    // HUD
    const pad = 10 * dpr; ctx.font = `${14 * dpr}px system-ui,-apple-system,Segoe UI,Roboto,Arial`; ctx.fillStyle = getCSS('--ink');
    ctx.fillText(`Skor: ${Math.floor(player.score).toLocaleString('tr-TR')}`, pad, 20 * dpr);
    ctx.fillText(`Çarpan: x${player.mult.toFixed(1)}`, pad, 38 * dpr);
    // "Shard" artık yok — satır kaldırıldı

    // HP bar
    const barW = 160 * dpr, barH = 10 * dpr; const hpR = clamp(player.hp / player.hpMax, 0, 1);
    ctx.fillStyle = '#1d2230'; ctx.fillRect(pad, 66 * dpr, barW, barH);
    ctx.fillStyle = getCSS('--acc1'); ctx.fillRect(pad, 66 * dpr, barW * hpR, barH);

    drawBarrierRingUI(); // UI halka en sonda
  }

  /* ---------- UI halka (barBtn) ---------- */
  function drawBarrierRingUI() {
    const w = ring.width, h = ring.height; rctx.clearRect(0, 0, w, h);
    const cx = w / 2, cy = h / 2; const rad = Math.min(w, h) / 2 - 6 * dpr;
    if (barrierAutoActive) {
      const ratio = clamp(barrierAutoTimer / barrierAutoDuration, 0, 1);
      rctx.lineWidth = 8 * dpr; rctx.strokeStyle = '#2ee66a';
      rctx.beginPath(); rctx.arc(cx, cy, rad, -Math.PI / 2, -Math.PI / 2 + ratio * 2 * Math.PI); rctx.stroke();
    } else if (barrierAutoReady) {
      rctx.lineWidth = 8 * dpr; rctx.strokeStyle = '#2ee66a';
      rctx.beginPath(); rctx.arc(cx, cy, rad, 0, Math.PI * 2); rctx.stroke();
    } else {
      const t = performance.now() / 700; const alpha = 0.75 + 0.25 * Math.sin(t);
      rctx.lineWidth = 8 * dpr; rctx.strokeStyle = `rgba(239,71,111,${alpha.toFixed(3)})`;
      rctx.beginPath(); rctx.arc(cx, cy, rad, 0, Math.PI * 2); rctx.stroke();
    }
  }

  /* ---------- oyun bitti ---------- */
  function endGame() {
    state = State.DEAD; menuEl.style.display = '';
    startBtn.textContent = 'YENİDEN BAŞLA';
    const s = Math.floor(player.score); if (s > bestScore) { bestScore = s; localStorage.setItem(LS_KEY, bestScore); bestEl.textContent = bestScore.toLocaleString('tr-TR'); }
  }

  /* ---------- döngü ---------- */
  function loop() {
    const t = now(); let dt = (t - tPrev) / 1000; tPrev = t;
    dt = Math.min(dt, 0.033);
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  /* ---------- diğer ---------- */
  addEventListener('visibilitychange', () => { if (document.hidden && state === State.PLAY) { state = State.PAUSE; menuEl.style.display = ''; } });
  addEventListener('blur', () => { if (state === State.PLAY) { state = State.PAUSE; menuEl.style.display = ''; } });
  canvas.addEventListener('click', () => audio.resume(), { once: true });
  document.addEventListener('keydown', e => { if ((e.key || '').toLowerCase() === 'm') muted = !muted; });

})();
</script>
</body>
</html>
